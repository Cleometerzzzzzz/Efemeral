#!/usr/bin/env python3

# Efemeral by Cleo. A CLI chat that attempts to emulate the IRC days of yore, entirely within your command line!
#
# You may not copy this code for any reason. This is not because you are forbidden from doing so.
# It's because my code fucking sucks.
#
# Issues:
#         - nickserv is totally broken. no clue what's causing it.
#         - NAT is a bitch and will continue to be a bitch.
#         - still no idea what i'm doing.
#         - i use bare excepts like I use commas, leading to the opposite of verbosity
#
# Added since last merge:
#         - ?cls / ?clear
#         - ?color
#         - better error handling in places (mostly for debugging purposes)

import socket
import threading
import argparse
import sys
import time
import uuid
import re
import shutil
import math
from urllib.parse import urlparse

BUFFER = 2048

clients = {}            # sock -> Client
nicks = {}              # nick -> sock
nickserv = {}           # nick -> password
bans = set()            # endpoint strings
invites = {}            # token -> Invite
motd = ""
host_assigned = False
lock = threading.Lock()


# data shit
class Client:
    def __init__(self, sock, addr, is_host=False):
        self.sock = sock
        self.endpoint = f"{addr[0]}:{addr[1]}"
        self.nick = self.endpoint
        self.is_host = is_host
        self.is_trusted = is_host
        self.joined = time.time()
        self.color = "\033[33m" if is_host else "\033[36m"  # gold / cyan


class Invite:
    def __init__(self, uses, expires):
        self.uses = uses
        self.expires = expires


# utils

def rgb_to_ansi(r, g, b):
    # Formula for RGB to 256-color ANSI code conversion
    return 16 + (36 * (r // 51)) + (6 * (g // 51)) + (b // 51)

def hex_to_rgb(hex_value):
    hex_value = hex_value.lstrip('#')
    if len(hex_value) == 6:
        r, g, b = (int(hex_value[i:i+2], 16) for i in (0, 2, 4))
    else:
        raise ValueError("Invalid hex value length.")
    return r, g, b

def get_terminal_width():
    return shutil.get_terminal_size().columns

def calculate_lines(text, terminal_width):
    adjusted_text = text
    num_lines = math.ceil(len(adjusted_text) / terminal_width)
    return num_lines

def clear_multiple_lines(num_lines):
    for _ in range(num_lines):
        sys.stdout.write("\033[A\033[2K")
        sys.stdout.flush()

def delete_text(text):
    terminal_width = get_terminal_width()
    num_lines = calculate_lines(text, terminal_width)
    clear_multiple_lines(num_lines)

def clear_screen():
    try:    
        sys.stdout.write("\033[H\033[J")  # ANSI escape sequence to clear screen
        sys.stdout.flush()
    except Exception as e:
        print(f"Exception while clearing: (e)")

def now():
    return int(time.time())


def send(sock, msg):
    try:
        sock.send((msg + "\n").encode())
    except:    # extremely dirty bare except. Bite me.
        pass


def broadcast(msg, exclude=None):
    for c in list(clients.values()):
        if c.sock != exclude:
            send(c.sock, msg)


def redraw(msg):
    # wipe input line, print message, fresh prompt
    sys.stdout.write("\r\033[K")
    sys.stdout.write(msg + "\n")
    sys.stdout.write("> ")
    sys.stdout.flush()


def fmt(text):
    text = re.sub(r'\\([*_])', r'\1', text)
    text = re.sub(r'(?<!\\)\*(.*?)\*(?!\*)', r'\033[1m\1\033[0m', text)
    text = re.sub(r'(?<!\\)_(.*?)_(?!_)', r'\033[3m\1\033[0m', text)
    return text


def get_public_ip():
    """
    best-effort public IP detection using stdlib only.
    does not send packets, just abuses routing tables.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]
    except:
        return None
    finally:
        s.close()


def advertised_host(bind_host):
    # never advertise garbage like 0.0.0.0 or localhost
    if bind_host in ("0.0.0.0", "127.0.0.1", "localhost", None):
        ip = get_public_ip()
        return ip if ip else bind_host
    return bind_host


# cmds
def require_op(c):
    return c.is_trusted

def cmd_color(c, args):
    if len(args) < 1:
        send(c.sock, "* Usage: ?color <HEX>")
        return

    color_value = args[0]
    hex_match = re.match(r"^#([0-9A-Fa-f]{6})$", color_value)
    if hex_match:
        try:
            r, g, b = hex_to_rgb(color_value)
            ansi_color_code = rgb_to_ansi(r, g, b)
            c.color = f"\033[38;5;{ansi_color_code}m"  # Set the ANSI color code
            send(c.sock, f"* Color updated!")
        except ValueError:
            send(c.sock, "* Invalid hex color code.")
        return

    # Check if the color is in RGB format (e.g., 255, 0, 255)
    rgb_match = re.match(r"^(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})$", color_value)
    if rgb_match:
        r, g, b = map(int, rgb_match.groups())
        if 0 <= r <= 255 and 0 <= g <= 255 and 0 <= b <= 255:
            ansi_color_code = rgb_to_ansi(r, g, b)
            c.color = f"\033[38;5;{ansi_color_code}m"  # Set the ANSI color code
            send(c.sock, f"* Color updated!")
        else:
            send(c.sock, "* RGB is not currently supported.")
        return

    send(c.sock, "* Invalid color format. Please use a hex code (#RRGGBB).")

def cmd_nick(c, args):
    if not args:
        return
    new = args[0]
    if new in nickserv:
        send(c.sock, "* Nick is registered.")
        return
    if new in nicks:
        send(c.sock, "* Nick already in use.")
        return
    old = c.nick
    nicks.pop(old, None)
    c.nick = new
    nicks[new] = c.sock
    broadcast(f"* {old} is now known as {new}")


def cmd_elevate(c, args):
    if not c.is_host or not args:
        return
    t = clients.get(nicks.get(args[0]))
    if t:
        t.is_trusted = True
        broadcast(f"* {t.nick} has been elevated")


def cmd_kick(c, args):
    if not require_op(c) or len(args) < 1:
        return
    target_nick = args[0]
    message = "You were kicked" if len(args) < 2 else " ".join(args[1:])
    t = clients.get(nicks.get(target_nick))
    if t:
        send(t.sock, f"* You were kicked by {c.nick}:\n* {message}")
        t.sock.close()


def cmd_ban(c, args):
    if not require_op(c) or len(args) < 1:
        return
    target_nick = args[0]
    message = "You were banned" if len(args) < 2 else " ".join(args[1:])
    t = clients.get(nicks.get(target_nick))
    if t:
        bans.add(t.endpoint)
        send(t.sock, f"* You were banned by {c.nick}:\n* {message}")
        t.sock.close()


def cmd_whois(c, args):
    if not args:
        return
    t = clients.get(nicks.get(args[0]))
    if not t:
        return
    uptime = now() - int(t.joined)
    role = "HOST" if t.is_host else "OP" if t.is_trusted else "PEER"
    send(c.sock, f"* {t.nick} | {t.endpoint} | {uptime}s | {role}")


def cmd_motd(c, args):
    global motd
    if not require_op(c):
        return
    motd = " ".join(args)
    broadcast(f"* MOTD set: {motd}")


def cmd_whisper(c, args):
    if len(args) < 2:
        return
    target_nick = args[0]
    message = " ".join(args[1:])
    t = clients.get(nicks.get(target_nick))
    if t:
        send(t.sock, f"\033[3m* {c.nick} whispered to you: {message}\033[0m")
        send(c.sock, f"\033[3m* You whispered to {t.nick}: {message}\033[0m")


def cmd_me(c, args):
    if not args:
        return
    action = " ".join(args)
    broadcast(f"* {c.color}{c.nick}\033[0m {fmt(action)}")


def cmd_clear():
    print("\033[H\033[J")

COMMANDS = {
    "nick": cmd_nick,
    "elevate": cmd_elevate,
    "kick": cmd_kick,
    "ban": cmd_ban,
    "whois": cmd_whois,
    "motd": cmd_motd,
    "w": cmd_whisper,
    "me": cmd_me,
    "color": cmd_color,
    "cls": cmd_clear,
    "clear": cmd_clear,
}


# when i'm the server
def handle_client(sock, addr, is_host):
    c = Client(sock, addr, is_host)

    if c.endpoint in bans:
        sock.close()
        return

    with lock:
        clients[sock] = c
        nicks[c.nick] = sock

    if motd:
        send(sock, f"* MOTD: {motd}")

    broadcast(f"* {c.nick} joined ({'HOST' if c.is_host else 'PEER'})")

    while True:  # when i recieve a message, check if it's a command'
        try:
            msg = sock.recv(BUFFER).decode().strip()
            if not msg:
                break
            if msg.startswith("?clear") or msg.startswith("?cls"):
                clear_screen()
                continue
            if msg.startswith("?"):
                parts = msg[1:].split()
                cmd = COMMANDS.get(parts[0])
                if cmd:
                    cmd(c, parts[1:])
                continue
            if msg.startswith("/me "):
                mecmd = msg.replace("/me ", "")
                broadcast(f"* {c.color}{c.nick}\033[0m {fmt(mecmd)}")    
                continue
            broadcast(f"{c.color}[{c.nick}]\033[0m {fmt(msg)}")

        except:
            break

    with lock:
        clients.pop(sock, None)
        nicks.pop(c.nick, None)

    broadcast(f"* {c.nick} left")
    sock.close()



def start_server(host, port):
    # make sure the host is trusted when they make the instance by giving the first client to connect admin privliges
    # since the host will always be the first client to connect under normal circumstances
    global host_assigned

    srv = socket.socket()
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind((host, port))
    srv.listen()

    def loop():
        global host_assigned
        while True:
            s, a = srv.accept()
            is_host = False
            if not host_assigned:
                is_host = True
                host_assigned = True
            threading.Thread(
                target=handle_client,
                args=(s, a, is_host),
                daemon=True
            ).start()

    threading.Thread(target=loop, daemon=True).start()


# when i'm the client
def listen(sock):
    while True:
        try:
            msg = sock.recv(BUFFER).decode()
            if not msg:
                break
            redraw(msg.strip())
        except:
            break


def input_loop(sock):
    while True:
        try:
            try:                
                msg = input("> ")
            except KeyboardInterrupt:
                print("\033[A")
                print("Exiting...")
                break
            sock.send(msg.encode())

            # clear echoed input immediately
            # Move the cursor up by 1 line
            delete_text(msg)

        except Exception as e:
            print(f"Error during input: {e}")
            break


def connect(host, port, nick):
    s = socket.socket()
    s.connect((host, port))
    threading.Thread(target=listen, args=(s,), daemon=True).start()
    s.send(f"?nick {nick}".encode())
    input_loop(s)


# initialization
def main():
    clear_screen()
    ap = argparse.ArgumentParser("efemeral_cli")
    ap.add_argument("--host", help="Highly reccomended to use 0.0.0.0 unless you know what you're doing.'")
    ap.add_argument("--port", type=int, required=True, help="the port that the instance will run on.")
    ap.add_argument("--passphrase", help="The passcode to lock the instance behind.")
    ap.add_argument("--nick", help="Nickname. Defaults to your endpoint.", required = True)
    ap.add_argument("--link", help="Required to join an already existing instance. Ask the host for the link.")
    args = ap.parse_args()

    if args.link:
        u = urlparse(args.link)
        host, port = u.netloc.split(":")
        connect(host, int(port), args.nick)
        return

    start_server(args.host, args.port)

    public_host = advertised_host(args.host)
    print("efemeral instance started")
    print(f"efemeral://{public_host}:{args.port}/{args.passphrase}")

    connect(args.host, args.port, args.nick)


if __name__ == "__main__":
    main()

